#!/usr/bin/env python3
"""
Build an EPANET INP from nodes.csv and edges.csv

Requirements:
- nodes.csv headers (exact, case-sensitive):
  NodeID,Type,Elevation_ft,BaseDemand_gpm,Pattern,X,Y,InitLevel_ft,MinLevel_ft,MaxLevel_ft

- edges.csv headers (exact, case-sensitive):
  LinkID,LinkType,Node1,Node2,Length_ft,Diameter_in,Roughness,Coefficient,Status

Behavior you asked for:
- If any pipe Length_ft is blank or 0 -> use 1 ft (EPANET disallows zero-length pipes)
- If a junction's Pattern is blank -> set to "StressTest"
- Run options baked in: D-W headloss, GPM units, 1-hour duration,
  3-min pattern/report/hyd steps
"""

from pathlib import Path
import csv
import sys

HERE = Path(__file__).resolve().parent
NODES_CSV = HERE / "nodes.csv"
EDGES_CSV = HERE / "edges.csv"
OUT_INP   = HERE / "auto_built.inp"

# ---- expected headers ----
NODES_HDR = [
    "NodeID","Type","Elevation_ft","BaseDemand_gpm","Pattern",
    "X","Y","InitLevel_ft","MinLevel_ft","MaxLevel_ft"
]
EDGES_HDR = [
    "LinkID","LinkType","Node1","Node2","Length_ft",
    "Diameter_in","Roughness","Coefficient","Status"
]

def read_csv(path, hdr_expected):
    if not path.exists():
        sys.exit(f"ERROR: Missing {path.name} in {path.parent}")
    with path.open(newline="") as f:
        r = csv.DictReader(f)
        hdr = r.fieldnames or []
        if hdr != hdr_expected:
            sys.exit(
                f"ERROR: {path.name} headers mismatch.\n"
                f"  Found : {hdr}\n"
                f"  Expect: {hdr_expected}"
            )
        rows = [dict(row) for row in r]
    return rows

def to_float(v, default=None):
    s = (v or "").strip()
    if s == "":
        return default
    try:
        return float(s)
    except ValueError:
        return default

def to_int(v, default=None):
    s = (v or "").strip()
    if s == "":
        return default
    try:
        return int(round(float(s)))
    except ValueError:
        return default

def main():
    nodes = read_csv(NODES_CSV, NODES_HDR)
    edges = read_csv(EDGES_CSV, EDGES_HDR)

    # --- index nodes ---
    node_ids = set()
    for n in nodes:
        nid = n["NodeID"].strip()
        if not nid:
            sys.exit("ERROR: nodes.csv contains a blank NodeID.")
        if nid in node_ids:
            sys.exit(f"ERROR: duplicate NodeID {nid}")
        node_ids.add(nid)

    # sanity: all link endpoints exist
    for e in edges:
        n1 = e["Node1"].strip()
        n2 = e["Node2"].strip()
        if n1 not in node_ids:
            sys.exit(f"ERROR: edges.csv Node1 '{n1}' not found in nodes.csv")
        if n2 not in node_ids:
            sys.exit(f"ERROR: edges.csv Node2 '{n2}' not found in nodes.csv")

    # categorize nodes
    juncs, tanks, ress = [], [], []
    for n in nodes:
        t = (n["Type"] or "").strip().lower()
        if t == "junction":
            juncs.append(n)
        elif t == "tank":
            tanks.append(n)
        elif t == "reservoir":
            ress.append(n)
        else:
            sys.exit(f"ERROR: NodeID {n['NodeID']} has invalid Type '{n['Type']}' "
                     f"(use Junction, Tank, or Reservoir)")

    # --- write INP ---
    with OUT_INP.open("w", newline="") as f:
        w = lambda s="": f.write(s + "\n")

        # Header
        w("[TITLE]")
        w("Generated by build_inp_from_csv.py")
        w()

        # Options (gold standard you asked for)
        w("[OPTIONS]")
        w(" UNITS               GPM")
        w(" HEADLOSS            D-W")
        w(" SPECIFIC GRAVITY    1.0")
        w(" VISCOSITY           1.0")
        w(" TRIALS              40")
        w(" ACCURACY            0.001")
        w(" CHECKFREQ           2")
        w(" MAXCHECK            10")
        w(" DAMPLIMIT           0.0")
        w()

        # Times (1 hr, 3-min pattern/report/hyd/qual)
        w("[TIMES]")
        w(" DURATION            1:00")
        w(" HYDRAULIC TIMESTEP  0:03")
        w(" QUALITY TIMESTEP    0:03")
        w(" PATTERN TIMESTEP    0:03")
        w(" PATTERN START       0:00")
        w(" REPORT TIMESTEP     0:03")
        w(" REPORT START        0:00")
        w(" START CLOCKTIME     0:00")
        w(" STATISTIC           NONE")
        w()

        # Patterns (StressTest = always 1.0)
        w("[PATTERNS]")
        w(";ID         24 hourly multipliers (constant=1)")
        w("StressTest  " + " ".join(["1"]*24))
        w()

        # Junctions (BaseDemand_gpm + Pattern)
        w("[JUNCTIONS]")
        w(";ID           Elev(ft)   Demand(GPM)  Pattern")
        for n in juncs:
            nid = n["NodeID"]
            elev = to_float(n["Elevation_ft"], 0.0) or 0.0
            bd   = to_float(n["BaseDemand_gpm"], 0.0) or 0.0
            pat  = (n["Pattern"] or "").strip()
            if pat == "":
                pat = "StressTest"  # your requested default
            w(f"{nid:<14} {elev:>8.2f}   {bd:>10.4f}  {pat}")
        w()

        # Reservoirs (EPANET wants HEAD, not elevation)
        # We’ll interpret Elevation_ft as head (typical when z=0 datum).
        w("[RESERVOIRS]")
        w(";ID           Head(ft)")
        for r in ress:
            rid = r["NodeID"]
            head = to_float(r["Elevation_ft"], 0.0) or 0.0
            w(f"{rid:<14} {head:>8.2f}")
        w()

        # Tanks
        # Use Elevation_ft as tank bottom elevation.
        # Require Init/Min/Max levels (ft above bottom). If blank, set a safe 10/0/20.
        w("[TANKS]")
        w(";ID           Elev(ft)  InitLvl  MinLvl  MaxLvl  Diam(ft)  MinVol  VolCurve")
        for tnk in tanks:
            tid   = tnk["NodeID"]
            elev  = to_float(tnk["Elevation_ft"], 0.0) or 0.0
            initl = to_float(tnk["InitLevel_ft"], 10.0) or 10.0
            minl  = to_float(tnk["MinLevel_ft"], 0.0) or 0.0
            maxl  = to_float(tnk["MaxLevel_ft"], 20.0) or 20.0
            diam  = 10.0
            w(f"{tid:<14} {elev:>8.2f}  {initl:>7.2f}  {minl:>6.2f}  {maxl:>6.2f}  {diam:>7.2f}  0")
        w()

        # Pipes / Pumps / Valves
        pipes, pumps, valves = [], [], []
        for e in edges:
            lt = (e["LinkType"] or "").strip().lower()
            if lt == "pipe":
                pipes.append(e)
            elif lt == "pump":
                pumps.append(e)
            else:
                # treat anything else as a valve (PRV/PSV/FCV etc.) if specified
                valves.append(e)

        w("[PIPES]")
        w(";ID           Node1         Node2         Length(ft)  Diameter(in)  Roughness  MinorLoss  Status")
        for p in pipes:
            lid  = p["LinkID"]
            n1   = p["Node1"].strip()
            n2   = p["Node2"].strip()
            L    = to_float(p["Length_ft"], 1.0)
            if not L or L <= 0:  # your rule
                L = 1.0
            d_in = to_float(p["Diameter_in"], 1.0) or 1.0
            C    = to_float(p["Roughness"], 130.0) or 130.0
            mls  = 0.0
            st   = (p["Status"] or "Open").strip().capitalize()
            if st not in ("Open", "Closed"):
                st = "Open"
            w(f"{lid:<14} {n1:<13} {n2:<13} {L:>10.2f}  {d_in:>11.3f}  {C:>9.2f}  {mls:>9.2f}  {st}")
        w()

        if pumps:
            w("[PUMPS]")
            w(";ID           Node1         Node2         Parameters")
            for pu in pumps:
                lid = pu["LinkID"]
                n1  = pu["Node1"].strip()
                n2  = pu["Node2"].strip()
                coef = (pu["Coefficient"] or "").strip()
                # Expecting a head curve ID in Coefficient (e.g., HEADCURVE1). If blank, write POWER 1 as fallback.
                if coef:
                    w(f"{lid:<14} {n1:<13} {n2:<13} HEAD {coef}")
                else:
                    w(f"{lid:<14} {n1:<13} {n2:<13} POWER 1.0")
            w()

            # Provide a simple default head curve if any pump referenced "HEADCURVE1"
            curve_ids = { (pu["Coefficient"] or "").strip() for pu in pumps }
            if "HEADCURVE1" in curve_ids:
                w("[CURVES]")
                w(";ID           X=Flow(GPM)   Y=Head(ft)")
                w("HEADCURVE1    0             150")
                w("HEADCURVE1    20            140")
                w("HEADCURVE1    40            110")
                w("HEADCURVE1    60             70")
                w()

        if valves:
            w("[VALVES]")
            w(";ID           Node1         Node2         Diam(in)  Type   Setting   MinorLoss")
            for v in valves:
                lid = v["LinkID"]
                n1  = v["Node1"].strip()
                n2  = v["Node2"].strip()
                d_in = to_float(v["Diameter_in"], 1.0) or 1.0
                # We’ll treat LinkType as the valve type literal (PRV/PSV/FCV/etc.)
                vtype = (v["LinkType"] or "PRV").strip().upper()
                setting = (v["Coefficient"] or "0").strip()
                mls = 0.0
                w(f"{lid:<14} {n1:<13} {n2:<13} {d_in:>7.2f}  {vtype:<5}  {setting:<8} {mls:>9.2f}")
            w()

        # Coordinates
        w("[COORDINATES]")
        w(";NodeID        X           Y")
        for n in nodes:
            nid = n["NodeID"]
            x = to_float(n["X"], 0.0) or 0.0
            y = to_float(n["Y"], 0.0) or 0.0
            w(f"{nid:<14} {x:>10.2f}  {y:>10.2f}")
        w()

        # End
        w("[END]")

    print(f"Done. INP written to: {OUT_INP}")

if __name__ == "__main__":
    main()
